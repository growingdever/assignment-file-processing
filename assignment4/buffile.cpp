// buffile.cc#include "buffile.h"#include <iostream>#include <stdio.h>#include "Student.h"using namespace std;BufferFile::BufferFile (IOBuffer & from)// create with a buffer: Buffer (from), last_deleted_index(-1){}int BufferFile::Open (const char * filename, int mode)// open an existing file and check the header// a correct header must be on the file// use ios::nocreate to ensure that a file exists{	File.open( filename, mode );	if( File.fail() ) {		cout << File.fail() << endl;		return FALSE;	}	HeaderSize = ReadHeader();	if (!HeaderSize) // no header and file opened for output		return FALSE;	File . seekp (HeaderSize, ios::beg);	File . seekg (HeaderSize, ios::beg);	return File.good();}int BufferFile::Create (const char * filename, int mode)// create a new file and write a header on it.// use ios::nocreate to ensure that no file exists{	if (!(mode & ios::out)) return FALSE; // must include ios::out	File.open (filename, mode | ios::trunc); // 생성할 때는 파일 비우고 시작	if (!File.good()) {		File.close();		return FALSE;	}	HeaderSize = WriteHeader ();	File.close();	return Open(filename, mode);}int BufferFile::Close (){	File.seekg (BufferHeaderSize, ios::beg);	File.seekp (BufferHeaderSize, ios::beg);	File.write ((char*)&last_deleted_index, sizeof(last_deleted_index));	File.close();	return TRUE;}int BufferFile::Rewind (){	File . seekg (HeaderSize, ios::beg);	File . seekp (HeaderSize, ios::beg);	return 1;}// Input and Output operationsint BufferFile::Read (int recaddr)// read a record into the buffer// return the record address// return <0 if read failed// if recaddr == -1, read the next record in the File// if recaddr != -1, read the record at that address{	if (recaddr == -1) {		int offset = Buffer . Read (File);		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		// 죽은 레코드면 다음 레코드 읽기 시도		if( ! student.GetAlive() ) {			return Read(-1);		}		return offset;	} else {		int offset = Buffer . DRead (File, recaddr);		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		// 죽은 레코드면 다음 레코드 읽기 시도		if( ! student.GetAlive() ) {			return Read(-1);		}		return offset;	}}int BufferFile::Write (int recaddr) // write the current buffer contents{	if (recaddr == -1)		return Buffer . Write (File);	else		return Buffer . DWrite (File, recaddr);}int BufferFile::Append ()// write the current buffer at the end of File{	// 중간에 빈 레코드가 없으면 파일 끝에 그냥 쓴다	if( last_deleted_index == -1 ) {		File.seekg(0, ios::end);		File.seekp(0, ios::end);		return Write(-1);	}	int record_size = Student::GetLengthForFixedFieldBuffer();	int recycled_record_offset = HeaderSize + record_size * last_deleted_index;	// 다음 삭제된 레코드 인덱스 가져옴	File.seekg (recycled_record_offset + 1, ios::beg);	File.seekp (recycled_record_offset + 1, ios::beg);	File.read((char*)&last_deleted_index, sizeof(last_deleted_index));	// 재활용할 레코드에 데이터 write	File.seekg (recycled_record_offset, ios::beg);	File.seekp (recycled_record_offset, ios::beg);	int writed_offset = Write(recycled_record_offset);	return writed_offset;}int BufferFile::Delete (int num_of_record, int pk_id) {	int record_size = Student::GetLengthForFixedFieldBuffer();	int prev_p = File.tellp();	int prev_g = File.tellg();	File . seekp (HeaderSize, ios::beg);	File . seekg (HeaderSize, ios::beg);	for( int i = 0; i < num_of_record; i ++ ) {		int offset = HeaderSize + record_size * i;		// Read를 할 때 dead record면 다음 record를 읽게 되어 있기 때문에		// 원래 목적한 offset과 Read 한 offset이 다르면 잘못 읽은 것이다.		int read_offset = Read( offset );		if( read_offset != offset ) {			continue;		}		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		if( student.GetAlive() && student.GetID() == pk_id ) {			printf("Deleted record index : %d\n", i);			File.seekg (offset, ios::beg);			File.seekp (offset, ios::beg);			// 죽은 레코드 표시 해놓고			student.SetAlive(false);			student.Pack (Buffer);			Write(offset);			// 삭제된 레코드 심볼을 남겨둬야 해서 한 칸 띄운다			File.seekg (offset + 1, ios::beg);			File.seekp (offset + 1, ios::beg);			File.write((char*)&last_deleted_index, sizeof(last_deleted_index));			// 마지막으로 삭제한 인덱스를 방금 삭제한 인덱스로 업데이트			last_deleted_index = i;			break;		}	}	File.seekg (prev_p, ios::beg);	File.seekp (prev_g, ios::beg);	return 0;}// Access to IOBufferIOBuffer & BufferFile::GetBuffer () {	return Buffer;}// protected methodsint BufferFile::ReadHeader (){	BufferHeaderSize = Buffer.ReadHeader(File);	// 헤더에 마지막으로 삭제한 레코드 인덱스 써뒀던걸 읽음	File.read((char*)&last_deleted_index, sizeof(last_deleted_index));	// 정상적으로 리스트가 만들어졌는지 확인하는 코드	// int index_of_record = last_deleted_index;	// int record_size = Student::GetLengthForFixedFieldBuffer();	// int count = 0;	// while(index_of_record != -1) {	// 	int offset = BufferHeaderSize + sizeof(int) + record_size * index_of_record;	// 	File.seekg (offset + 1, ios::beg);	// 	File.seekp (offset + 1, ios::beg);	// 	File.read((char*)&index_of_record, sizeof(index_of_record));	// }	return BufferHeaderSize + sizeof(last_deleted_index);}int BufferFile::WriteHeader (){	BufferHeaderSize = Buffer.WriteHeader( File );	// 헤더에 마지막으로 삭제한 레코드 인덱스 써둠	File.write((char*)&last_deleted_index, sizeof(last_deleted_index));	return BufferHeaderSize + sizeof(last_deleted_index);}