// buffile.cc#include "buffile.h"#include <iostream>#include <stdio.h>#include "Student.h"using namespace std;BufferFile::BufferFile (IOBuffer & from)// create with a buffer: Buffer (from), last_deleted_index(-1){}int BufferFile::Open (const char * filename, int mode)// open an existing file and check the header// a correct header must be on the file// use ios::nocreate to ensure that a file exists{	File.open( filename, mode );	if( File.fail() ) {		cout << File.fail() << endl;		return FALSE;	}	HeaderSize = ReadHeader();	if (!HeaderSize) // no header and file opened for output		return FALSE;	File . seekp (HeaderSize, ios::beg);	File . seekg (HeaderSize, ios::beg);	return File.good();}int BufferFile::Create (const char * filename, int mode)// create a new file and write a header on it.// use ios::nocreate to ensure that no file exists{	if (!(mode & ios::out)) return FALSE; // must include ios::out	File.open (filename, mode);	if (!File.good()) {		File.close();		return FALSE;	}	HeaderSize = WriteHeader ();	File.close();	return Open(filename, mode);}int BufferFile::Close (){	File.seekg (BufferHeaderSize, ios::beg);	File.seekp (BufferHeaderSize, ios::beg);	File.write ((char*)&last_deleted_index, sizeof(last_deleted_index));	File.close();	return TRUE;}int BufferFile::Rewind (){	File . seekg (HeaderSize, ios::beg);	File . seekp (HeaderSize, ios::beg);	return 1;}// Input and Output operationsint BufferFile::Read (int recaddr)// read a record into the buffer// return the record address// return <0 if read failed// if recaddr == -1, read the next record in the File// if recaddr != -1, read the record at that address{	if (recaddr == -1) {		int offset = Buffer . Read (File);		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		if( ! student.GetAlive() ) {			return Read(-1);		}		return offset;	} else {		int offset = Buffer . DRead (File, recaddr);		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		if( ! student.GetAlive() ) {			return Read(-1);		}		return offset;	}}int BufferFile::Write (int recaddr) // write the current buffer contents{	if (recaddr == -1)		return Buffer . Write (File);	else		return Buffer . DWrite (File, recaddr);}int BufferFile::Append ()// write the current buffer at the end of File{	File . seekp (0, ios::end);	return Buffer . Write (File);}int BufferFile::Delete (int num_of_record, int pk_id) {	int record_size = Student::GetLengthForFixedFieldBuffer();	int prev_p = File.tellp();	int prev_g = File.tellg();	File . seekp (HeaderSize, ios::beg);	File . seekg (HeaderSize, ios::beg);	for( int i = 0; i < num_of_record; i ++ ) {		int offset = HeaderSize + record_size * i;		// Read를 할 때 dead record면 다음 record를 읽게 되어 있기 때문에		// 원래 목적한 offset과 Read 한 offset이 다르면 잘못 읽은 것이다.		int read_offset = Read( offset );		if( read_offset != offset ) {			continue;		}		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		if( student.GetAlive() && student.GetID() == pk_id ) {			File.seekg (offset, ios::beg);			File.seekp (offset, ios::beg);			student.SetAlive(false);			student.Pack (Buffer);			Write(offset);			// 삭제된 레코드 심볼을 남겨둬야 해서 한 칸 띄운다			File.seekg (offset + 1, ios::beg);			File.seekp (offset + 1, ios::beg);			File.write((char*)&last_deleted_index, sizeof(last_deleted_index));			// 마지막으로 삭제한 인덱스를 방금 삭제한 인덱스로 업데이트			last_deleted_index = i;			break;		}	}	File.seekg (prev_p, ios::beg);	File.seekp (prev_g, ios::beg);	return 0;}// Access to IOBufferIOBuffer & BufferFile::GetBuffer () {	return Buffer;}// protected methodsint BufferFile::ReadHeader (){	BufferHeaderSize = Buffer.ReadHeader(File);	File.read((char*)&last_deleted_index, sizeof(last_deleted_index));	// 정상적으로 리스트가 만들어졌는지 확인하는 코드	// int index_of_record = last_deleted_index;	// int record_size = Student::GetLengthForFixedFieldBuffer();	// int count = 0;	// while(index_of_record != -1 && count++ < 10) {	// 	int offset = BufferHeaderSize + sizeof(int) + record_size * index_of_record;	// 	File.seekg (offset + 1, ios::beg);	// 	File.seekp (offset + 1, ios::beg);	// 	File.read((char*)&index_of_record, sizeof(index_of_record));	// }	return BufferHeaderSize + sizeof(last_deleted_index);}int BufferFile::WriteHeader (){	BufferHeaderSize = Buffer.WriteHeader( File );	File.write((char*)&last_deleted_index, sizeof(last_deleted_index));	return BufferHeaderSize + sizeof(last_deleted_index);}