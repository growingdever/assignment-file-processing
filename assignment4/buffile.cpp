// buffile.cc#include "buffile.h"#include <iostream>#include "Student.h"using namespace std;BufferFile::BufferFile (IOBuffer & from) // create with a buffer	: Buffer (from){}int BufferFile::Open (const char * filename, int mode)// open an existing file and check the header// a correct header must be on the file// use ios::nocreate to ensure that a file exists{	File.open( filename, mode );	if( File.fail() ) {		cout << File.fail() << endl;		return FALSE;	}	return File.good();}int BufferFile::Create (const char * filename, int mode)// create a new file and write a header on it.// use ios::nocreate to ensure that no file exists{	if (!(mode & ios::out)) return FALSE; // must include ios::out	File . open (filename, mode);	if (!File . good()) 	{		File . close();		return FALSE;	}	HeaderSize = WriteHeader ();	return HeaderSize != 0;}int BufferFile::Close (){	File . close();	return TRUE;}int BufferFile::Rewind (){	File . seekg (HeaderSize, ios::beg);	File . seekp (HeaderSize, ios::beg);	return 1;}// Input and Output operationsint BufferFile::Read (int recaddr)// read a record into the buffer// return the record address// return <0 if read failed// if recaddr == -1, read the next record in the File// if recaddr != -1, read the record at that address{	if (recaddr == -1) {		return Buffer . Read (File);	} else {		return Buffer . DRead (File, recaddr);	}} int BufferFile::Write (int recaddr) // write the current buffer contents{	if (recaddr == -1)		return Buffer . Write (File);	else		return Buffer . DWrite (File, recaddr);}int BufferFile::Append ()// write the current buffer at the end of File{	File . seekp (0, ios::end);	return Buffer . Write (File);}int BufferFile::Delete (int num_of_record, int pk_id) {	int record_size = Student::GetLengthForFixedFieldBuffer();	int prev_p = File.tellp();	int prev_g = File.tellg();	File.seekg (0, ios::beg);	File.seekp (0, ios::beg);	for( int i = 1; i <= num_of_record; i ++ ) {		int offset = record_size * (num_of_record - i);		Read( offset );		Student student(0, "", "", "", 0);		student.Unpack( Buffer );		if( student.GetID() == pk_id ) {			File.seekg (offset, ios::beg);			File.seekp (offset, ios::beg);			student.SetAlive(false);			student.Pack (Buffer);			Write(offset);			break;		}	}	File.seekg (prev_p, ios::beg);	File.seekp (prev_g, ios::beg);	return 0;}// Access to IOBufferIOBuffer & BufferFile::GetBuffer () {	return Buffer;}// protected methodsint BufferFile::ReadHeader (){	return Buffer . ReadHeader (File);	}int BufferFile::WriteHeader (){	return Buffer . WriteHeader (File);}